/**
 * AI Content Generator Service
 * Main service for generating Turkish event content with cultural context
 */

import type { 
  UniqueEvent, 
  CanonicalVenue, 
  TurkishCulturalContext 
} from '@/lib/types';

import { 
  generateTurkishEventContent, 
  generateEventTypeContent,
  type EventContentContext 
} from './content-templates';

import { 
  analyzeCulturalContext
} from './cultural-context';

import { createClient } from '@/lib/supabase/client';

export interface ContentGenerationResult {
  success: boolean;
  content?: string;
  cultural_context?: TurkishCulturalContext;
  error?: string;
  metadata?: {
    language: string;
    content_version: string;
    cultural_context: boolean;
    generated_at: string;
    template_version: string;
  };
}

/**
 * Generate comprehensive Turkish content for an event
 */
export async function generateEventContent(
  eventId: string,
  options: {
    language?: 'tr' | 'en';
    include_pricing?: boolean;
    cultural_optimization?: boolean;
  } = {}
): Promise<ContentGenerationResult> {
  try {
    const supabase = createClient();
    
    // Fetch event data with venue information
    const { data: eventData, error: eventError } = await supabase
      .from('unique_events')
      .select(`
        *,
        venue:canonical_venues(*)
      `)
      .eq('id', eventId)
      .single();
    
    if (eventError || !eventData) {
      return {
        success: false,
        error: `Event not found: ${eventError?.message}`
      };
    }
    
    const event = eventData as UniqueEvent & { venue: CanonicalVenue };
    
    // Analyze cultural context
    const cultural_context = options.cultural_optimization !== false 
      ? analyzeCulturalContext(event, event.venue)
      : undefined;
    
    // Fetch pricing information if requested
    let pricing = undefined;
    if (options.include_pricing && event.providers) {
      pricing = await fetchEventPricing(event.id, event.providers);
    }
    
    // Build content context
    const contentContext: EventContentContext = {
      event,
      venue: event.venue,
      pricing,
      cultural_context
    };
    
    // Generate content based on event type
    const eventType = determineEventType(event);
    const content = eventType 
      ? generateEventTypeContent(eventType, contentContext)
      : generateTurkishEventContent(contentContext);
    
    // Generate metadata
    const metadata = {
      language: options.language || 'tr',
      content_version: '1.0',
      cultural_context: !!cultural_context,
      generated_at: new Date().toISOString(),
      template_version: '1.0'
    };
    
    return {
      success: true,
      content,
      cultural_context,
      metadata
    };
    
  } catch (error) {
    return {
      success: false,
      error: `Content generation failed: ${(error as Error).message}`
    };
  }
}

/**
 * Generate and save content to knowledge base
 */
export async function generateAndSaveEventContent(
  eventId: string,
  options: {
    language?: 'tr' | 'en';
    include_pricing?: boolean;
    cultural_optimization?: boolean;
    overwrite?: boolean;
  } = {}
): Promise<ContentGenerationResult & { saved: boolean }> {
  try {
    // Check if content already exists
    const supabase = createClient();
    
    if (!options.overwrite) {
      const { data: existing } = await supabase
        .from('event_knowledge_sections')
        .select('id')
        .eq('event_id', eventId)
        .limit(1);
      
      if (existing && existing.length > 0) {
        return {
          success: false,
          saved: false,
          error: 'Content already exists. Use overwrite option to replace.'
        };
      }
    }
    
    // Generate content
    const result = await generateEventContent(eventId, options);
    
    if (!result.success || !result.content) {
      return { ...result, saved: false };
    }
    
    // Save to knowledge base (will be processed by Edge Function for embedding)
    const { error: insertError } = await supabase
      .from('event_knowledge_sections')
      .insert({
        event_id: eventId,
        content: result.content,
        embedding: null, // Will be generated by Edge Function
        metadata: result.metadata
      });
    
    if (insertError) {
      return {
        success: false,
        saved: false,
        error: `Failed to save content: ${insertError.message}`
      };
    }
    
    return {
      ...result,
      saved: true
    };
    
  } catch (error) {
    return {
      success: false,
      saved: false,
      error: `Save operation failed: ${(error as Error).message}`
    };
  }
}

/**
 * Batch generate content for multiple events
 */
export async function batchGenerateEventContent(
  eventIds: string[],
  options: {
    language?: 'tr' | 'en';
    include_pricing?: boolean;
    cultural_optimization?: boolean;
    batch_size?: number;
    progress_callback?: (processed: number, total: number) => void;
  } = {}
): Promise<{
  success: boolean;
  processed: number;
  errors: { eventId: string; error: string }[];
  results: (ContentGenerationResult & { eventId: string })[];
}> {
  const batchSize = options.batch_size || 10;
  const results: (ContentGenerationResult & { eventId: string })[] = [];
  const errors: { eventId: string; error: string }[] = [];
  let processed = 0;
  
  // Process in batches to avoid overwhelming the system
  for (let i = 0; i < eventIds.length; i += batchSize) {
    const batch = eventIds.slice(i, i + batchSize);
    
    const batchPromises = batch.map(async (eventId) => {
      try {
        const result = await generateAndSaveEventContent(eventId, {
          ...options,
          overwrite: true // Allow overwriting in batch operations
        });
        return { ...result, eventId };
      } catch (error) {
        errors.push({ 
          eventId, 
          error: (error as Error).message 
        });
        return null;
      }
    });
    
    const batchResults = await Promise.allSettled(batchPromises);
    
    batchResults.forEach((result) => {
      if (result.status === 'fulfilled' && result.value) {
        results.push(result.value);
        processed++;
      }
    });
    
    // Report progress
    if (options.progress_callback) {
      options.progress_callback(processed, eventIds.length);
    }
    
    // Small delay between batches to prevent overwhelming the database
    if (i + batchSize < eventIds.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  return {
    success: errors.length === 0,
    processed,
    errors,
    results
  };
}

/**
 * Helper functions
 */
async function fetchEventPricing(
  _eventId: string, 
  _providers: string[]
): Promise<EventContentContext['pricing']> {
  // This would fetch actual pricing data from platform-specific tables
  // For now, return empty to avoid database complexity
  return [];
}

function determineEventType(
  event: UniqueEvent
): 'music' | 'theater' | 'comedy' | 'sports' | 'exhibition' | null {
  const genre = event.genre?.toLowerCase();
  const name = event.name?.toLowerCase();
  
  // Music events
  if (genre?.includes('music') || 
      genre?.includes('concert') ||
      genre?.includes('müzik') ||
      genre?.includes('konser')) {
    return 'music';
  }
  
  // Theater events
  if (genre?.includes('theater') || 
      genre?.includes('tiyatro') ||
      name?.includes('oyun')) {
    return 'theater';
  }
  
  // Comedy events
  if (genre?.includes('comedy') || 
      genre?.includes('komedi') ||
      name?.includes('stand up')) {
    return 'comedy';
  }
  
  // Sports events
  if (genre?.includes('sports') || 
      genre?.includes('spor') ||
      name?.includes('maç')) {
    return 'sports';
  }
  
  // Exhibitions
  if (genre?.includes('exhibition') || 
      genre?.includes('sergi') ||
      name?.includes('galeri')) {
    return 'exhibition';
  }
  
  return null;
}

/**
 * Get sample content for testing
 */
export function generateSampleContent(): string {
  return `Bu örnek etkinlik, İstanbul'un kalbinde yer alan prestijli bir mekanda gerçekleşecek. 
Hafta sonu eğlencesini doya doya yaşayabileceğiniz bu etkinlik, akşam saatlerinin enerjisiyle birleşecek. 
Müzikseverlerin buluşma noktası olan bu konserde, kaliteli ses sistemi ve profesyonel sahne düzeni ile 
unutulmaz bir deneyim yaşayacaksınız. Metro ile kolayca ulaşabileceğiniz konumda. 
Bu büyük kapasiteli etkinlik, binlerce kişiyle birlikte unutulmaz anlar yaşamanızı sağlayacak.`;
}